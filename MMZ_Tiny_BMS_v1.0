/*             Вітаю в Arduino IDE чаті! (Тусуємоcя на платформі ATTINY 13A)
 *   1) Придумайте собі нік і запишіть до cпівавторів
 *   2) Будь-які виправлення коментуйте і підписуйте своїм ніком
 *             Співавтори:       
 *   1) Dj_Elektrik
 *   2) Anonym
 *   3) AlexGyver
 *
 *                                        ATTINY 13A  PINOUT
 *                                             _________
 *  Як він сюди завів калібровку?    Reset   <|   \_/   |>   VCC
 *  Балансування                     A3  D3  <|         |>   D2  A1       Мала бути індикація, але буде калібровка
 *  Вимірювання напруги              A2  D4  <|         |>   D1  PWM      Транзистор заряду   0 - ON     1 - OFF
 *                                   GND     <|_________|>   D0  PWM      Транзистор розряду  0 - OFF    1 - ON
 *
 * на нозі RESET може сидіти переривання/РЕЗЕТ/ADC0 маркована ця нога в системі PB5ю так що сюди можна запросто достукуватись як до аналоговоі/цифровоі ноги (Anonym)
 * на ногу Д2 можна повісити дешевий регістр зсуву, будете мати більше ніг для індикаціі, тощо (Anonym)
********************************** Малоходачківський машинобудівний завод імені Ілона Маска, 09.08.2022р.*******************************************************
 */
#include <Arduino.h>            //  Бібліотека стандартних функцій Arduino, потрібна при прошиванні "голого каменю" програматором (Dj_Elektrik)
#include <avr/eeprom.h>         //  Стандартна бібліотека для EEPROM пам'яті (Dj_Elektrik)
byte i = 0;                     //  Змінна кількості запису EEPROM під час калібрування (Dj_Elektrik)
uint16_t poh_e;                 //  Змінна похибки, добутої з EEPROM (Dj_Elektrik)
word Ubatt;                     //  Змінна напруги акумулятора, залишив word щоб не натрапити на переповнення (Dj_Elektrik)
int32_t pause;                  //  Змінна затримки часу для функції millis()  (Dj_Elektrik)
const word Lp = 617;            //  Відключення розряду по низькій напрузі 2,9В (Dj_Elektrik)
const word Lp_his = 653;        //  Включення розряду 3,1В (Dj_Elektrik)
const word B = 831;             //  Напруга балансування 4,05В (Dj_Elektrik)
const word Hp = 840;            //  Напруга відключення процесу заряду 4,15В (Dj_Elektrik)
const word Hp_his = 831;        //  Напруга включення процесу заряду 4,08В (Dj_Elektrik)
word adr = 22;                  //  Адрес комірки пам'яті EEPROM (якщо не поможе то поставте тип uint16_t) (Dj_Elektrik)
bool NUM_READ = 64;             //  Кількість додаваннь для фільтру середнього арифметичного (Dj_Elektrik)
                                //  Попри наявність калібровки, довелося вручну редагувати константи, (Dj_Elektrik)
                                //  тому вони не зходяться з розрахованими по напрузі (близько 0,0055В на один відлік АЦП) (Dj_Elektrik)

void setup() {
  //Serial.begin(9600);
  pinMode(2, INPUT_PULLUP);               //  Для калібровки подати на вхід 2,9В, замкнути D2 на землю (Dj_Elektrik)
  pinMode(3, OUTPUT);                     //  Балансування                0 - OFF    1 - ON (Dj_Elektrik)
  pinMode(0, OUTPUT);                     //  Транзистор розряду          0 - OFF    1 - ON (Dj_Elektrik)
  pinMode(1, OUTPUT);                     //  Транзистор заряду           0 - ON     1 - OFF (Dj_Elektrik)
  analogReference(INTERNAL);              //  Підключення внутрішньої опорної напруги 1,1В (Dj_Elektrik)
                              
}
void loop() {
  if(millis()>1000){         // Затримка для того, щоб одразу після подачі живлення мікроконтролер 1с ігнорував подальший код в дужках і зміг розрахувати напругу на акумуляторі  (Dj_Elektrik)
    if (Ubatt > B){          // Якщо напруга на акумуляторі вище, ніж напруга балансування (Dj_Elektrik)
    digitalWrite(3,1);       // Включаємо балансування (Dj_Elektrik)
    delay(500);              // Не реагуємо ні на що, тому що на балансувальних проводах є падіння напруги і вимірювання будуть некоректними (Dj_Elektrik)
    digitalWrite(3,0);       // Виключаємо балансування, щоб виміряти правильну напругу на акумуляторі (Dj_Elektrik)
    delay(30);               // Чекаємо поки виключиться транзистор, зарядиться конденсатор по живленню та фільтруючий конденсатор на вході АЦП (Dj_Elektrik)
   }
  }
  uint16_t adc_s = midArifm(analogRead(A2));
    
  if(millis()>1000 && digitalRead(2) == 0 && i<5) {      //  Калібровка (добавив затримку, тому що само калібрувалося при включенні) (Dj_Elektrik)

    uint16_t poh = Lp + 1000 - adc_s;                   //  Рахуємо похибку вимірювання, додаю 1000 щоб мати запас в дві сторони без знаку (Dj_Elektrik)
    eeprom_update_word(reinterpret_cast<uint16_t *>(adr), poh);     //  Оновлюємо інформацію в EEPROM, якщо є зміни  (Dj_Elektrik)                                                     
    i = i + 1;                                          //  Обмежуємо кількість ітерацій, щоб не дрочити EEPROM (Dj_Elektrik)
  }
  poh_e = eeprom_read_word(reinterpret_cast<const uint16_t *>(adr));                    //  Добуваємо записану похибку (Dj_Elektrik)
  Ubatt = adc_s + poh_e - 1000;                         //  Рахуємо напругу на акумуляторі 570...825 попугаїв (Dj_Elektrik)

   if (Ubatt <= Lp) {                                   //  Основний алгоритм роботи (Dj_Elektrik)
    digitalWrite(0,0);
    pause = millis();
   }
   if (Ubatt > Lp_his && millis()-pause>2000)  digitalWrite(0,1);
   if (Ubatt > Hp){
    digitalWrite(1,1);
    pause = millis();
   }
   if (Ubatt <= Hp_his && millis()-pause>20000) digitalWrite(1,0);
   }
/*********** Функція (підпрограма) фільтр середнє арифметичне **************/
  uint16_t midArifm(uint16_t data) {
  uint16_t sum = 0;                      // локальная переменная sum (AlexGyver)
  for (byte i = 0; i < NUM_READ; i++)    // согласно количеству усреднений (AlexGyver)
    sum += data;                         // суммируем значения с любого датчика в переменную sum (AlexGyver)
  return (sum / NUM_READ);
}
